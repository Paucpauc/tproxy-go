
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tproxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tproxy/cmd/tproxy/main.go (0.0%)</option>
				
				<option value="file1">tproxy/internal/config/config.go (90.9%)</option>
				
				<option value="file2">tproxy/internal/proxy/proxy.go (79.8%)</option>
				
				<option value="file3">tproxy/internal/server/server.go (24.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"

        "tproxy/internal/config"
        "tproxy/internal/server"
)

func main() <span class="cov0" title="0">{
        configPath := flag.String("config", "proxy_config.yaml", "Path to YAML config file")
        flag.Parse()

        // Load configuration
        config, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Starting proxy server with config from %s\n", *configPath)

        // Start servers
        if err := server.StartServers(config); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start servers: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "regexp"
        "strconv"

        "gopkg.in/yaml.v3"
)

const (
        DEFAULT_HTTPS_PORT = 443
        DEFAULT_HTTP_PORT  = 80
        BUFFER_SIZE        = 4096
)

type ListenConfig struct {
        Host      string `yaml:"host"`
        HTTPSPort int    `yaml:"https_port"`
        HTTPPort  int    `yaml:"http_port"`
}

type Rule struct {
        Pattern string `yaml:"pattern"`
        Proxy   string `yaml:"proxy"`
}

type Config struct {
        Listen ListenConfig `yaml:"listen"`
        Rules  []Rule       `yaml:"rules"`
}

var DefaultConfig = Config{
        Listen: ListenConfig{
                Host:      "127.0.0.1",
                HTTPSPort: 3130,
                HTTPPort:  3131,
        },
        Rules: []Rule{
                {Pattern: ".*", Proxy: "DIRECT"},
        },
}

func LoadConfig(configPath string) (*Config, error) <span class="cov8" title="1">{
        if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                fmt.Printf("Config file %s not found, using default config\n", configPath)
                return &amp;DefaultConfig, nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Merge with default config to ensure all required fields exist
        <span class="cov8" title="1">if config.Listen.Host == "" </span><span class="cov0" title="0">{
                config.Listen.Host = DefaultConfig.Listen.Host
        }</span>
        <span class="cov8" title="1">if config.Listen.HTTPSPort == 0 </span><span class="cov8" title="1">{
                config.Listen.HTTPSPort = DefaultConfig.Listen.HTTPSPort
        }</span>
        <span class="cov8" title="1">if config.Listen.HTTPPort == 0 </span><span class="cov8" title="1">{
                config.Listen.HTTPPort = DefaultConfig.Listen.HTTPPort
        }</span>
        <span class="cov8" title="1">if len(config.Rules) == 0 </span><span class="cov0" title="0">{
                config.Rules = DefaultConfig.Rules
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

type ProxyAction struct {
        Type string // "DIRECT", "PROXY", "DROP"
        Host string
        Port int
}

func FindProxyForHost(host string, rules []Rule) (*ProxyAction, error) <span class="cov8" title="1">{
        for _, rule := range rules </span><span class="cov8" title="1">{
                matched, err := regexp.MatchString(rule.Pattern, host)
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("Invalid regex pattern: %s\n", rule.Pattern)
                        continue</span>
                }

                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                        switch rule.Proxy </span>{
                        case "DIRECT":<span class="cov8" title="1">
                                return &amp;ProxyAction{Type: "DIRECT"}, nil</span>
                        case "DROP":<span class="cov8" title="1">
                                return &amp;ProxyAction{Type: "DROP"}, nil</span>
                        default:<span class="cov8" title="1">
                                // Parse proxy host:port
                                host, port := parseProxyAddress(rule.Proxy)
                                return &amp;ProxyAction{
                                        Type: "PROXY",
                                        Host: host,
                                        Port: port,
                                }, nil</span>
                        }
                }
        }

        // Fallback to DIRECT if no rules match
        <span class="cov0" title="0">return &amp;ProxyAction{Type: "DIRECT"}, nil</span>
}

func parseProxyAddress(proxy string) (string, int) <span class="cov8" title="1">{
        // Simple parsing for host:port format
        // Default to port 3128 if not specified
        host := proxy
        port := 3128

        // Look for the last colon (to handle IPv6 addresses correctly)
        lastColon := -1
        for i := len(proxy) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if proxy[i] == ':' </span><span class="cov8" title="1">{
                        lastColon = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if lastColon != -1 </span><span class="cov8" title="1">{
                host = proxy[:lastColon]
                portStr := proxy[lastColon+1:]
                if portStr != "" </span><span class="cov8" title="1">{
                        // Try to parse port
                        if p, err := strconv.Atoi(portStr); err == nil </span><span class="cov8" title="1">{
                                port = p
                        }</span>
                }
        }

        <span class="cov8" title="1">return host, port</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package proxy

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "net"
        "strconv"
        "strings"
        "sync"
)

func ParseHTTPHost(data []byte) (string, int) <span class="cov8" title="1">{
        reader := bufio.NewReader(bytes.NewReader(data))

        // Read the first line (request line)
        _, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", 80
        }</span>

        // Read headers until we find Host header
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                line, err := reader.ReadString('\n')
                if err != nil || line == "\r\n" </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(line, "Host: ") </span><span class="cov8" title="1">{
                        hostStr := strings.TrimSpace(strings.TrimPrefix(line, "Host: "))
                        parts := strings.Split(hostStr, ":")
                        host := parts[0]
                        port := 80

                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                if p, err := strconv.Atoi(parts[1]); err == nil </span><span class="cov8" title="1">{
                                        port = p
                                }</span>
                        }
                        <span class="cov8" title="1">return host, port</span>
                }
        }

        <span class="cov8" title="1">return "", 80</span>
}

func ParseSNI(data []byte) string <span class="cov8" title="1">{
        // Find TLS handshake in the data (skip TCP/IP headers)
        startPos := -1
        for i := 0; i &lt; len(data)-2; i++ </span><span class="cov8" title="1">{
                if data[i] == 0x16 &amp;&amp; data[i+1] == 0x03 &amp;&amp; (data[i+2] == 0x01 || data[i+2] == 0x02 || data[i+2] == 0x03) </span><span class="cov8" title="1">{
                        startPos = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if startPos == -1 </span><span class="cov8" title="1">{
                return "" // Not a TLS handshake found
        }</span>

        // Use data starting from TLS handshake
        <span class="cov8" title="1">data = data[startPos:]

        // Check if this is a TLS handshake
        if len(data) &lt; 5 || data[0] != 0x16 </span><span class="cov8" title="1">{
                return "" // Not a TLS handshake
        }</span>

        // Parse TLS record header
        <span class="cov8" title="1">recordLength := int(data[3])&lt;&lt;8 | int(data[4])
        // Don't require complete record - we only need the beginning to parse SNI
        // if len(data) &lt; 5+recordLength {
        //         return "" // Incomplete record
        // }

        // Check if this is a ClientHello
        if len(data) &lt; 9 || data[5] != 0x01 </span><span class="cov0" title="0">{
                return "" // Not a ClientHello or insufficient data
        }</span>

        // Parse handshake length (3 bytes)
        <span class="cov8" title="1">handshakeLength := int(data[6])&lt;&lt;16 | int(data[7])&lt;&lt;8 | int(data[8])

        // The handshake length should be &lt;= recordLength - 4 (handshake type + length bytes)
        if handshakeLength &gt; recordLength-4 </span><span class="cov0" title="0">{
                // Use record length as fallback if handshake length seems invalid
                handshakeLength = recordLength - 4
        }</span>

        // Don't require complete handshake - we only need the beginning to parse SNI
        // if len(data) &lt; 9+handshakeLength {
        //         return "" // Incomplete handshake
        // }

        // Start parsing ClientHello at position 9
        <span class="cov8" title="1">pos := 9

        // Skip ClientVersion (2 bytes)
        if pos+2 &gt; len(data) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">pos += 2

        // Skip Random (32 bytes)
        if pos+32 &gt; len(data) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">pos += 32

        // Skip SessionID (1 byte length + session data)
        if pos &gt;= len(data) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">sessionIDLen := int(data[pos])
        pos++
        if pos+sessionIDLen &gt; len(data) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">pos += sessionIDLen

        // Skip CipherSuites (2 bytes length + cipher suites)
        if pos+2 &gt; len(data) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">cipherSuitesLen := int(data[pos])&lt;&lt;8 | int(data[pos+1])
        pos += 2
        if pos+cipherSuitesLen &gt; len(data) </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">pos += cipherSuitesLen

        // Skip CompressionMethods (1 byte length + methods)
        if pos &gt;= len(data) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">compressionMethodsLen := int(data[pos])
        pos++
        if pos+compressionMethodsLen &gt; len(data) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">pos += compressionMethodsLen

        // Check if we have extensions
        if pos+2 &gt; len(data) </span><span class="cov0" title="0">{
                return "" // No extensions
        }</span>

        <span class="cov8" title="1">extensionsLength := int(data[pos])&lt;&lt;8 | int(data[pos+1])
        pos += 2

        // Parse extensions
        extensionsEnd := pos + extensionsLength
        if extensionsEnd &gt; len(data) </span><span class="cov8" title="1">{
                // If extensions exceed data length, use available data
                extensionsEnd = len(data)
        }</span>

        <span class="cov8" title="1">for pos &lt; extensionsEnd-4 </span><span class="cov8" title="1">{
                // Parse extension header
                extType := int(data[pos])&lt;&lt;8 | int(data[pos+1])
                extLength := int(data[pos+2])&lt;&lt;8 | int(data[pos+3])
                pos += 4

                if pos+extLength &gt; len(data) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check for Server Name Indication (type 0x0000)
                <span class="cov8" title="1">if extType == 0x0000 </span><span class="cov8" title="1">{
                        // Parse SNI extension data
                        if extLength &lt; 2 </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // ServerNameList length
                        <span class="cov8" title="1">listLength := int(data[pos])&lt;&lt;8 | int(data[pos+1])
                        pos += 2

                        if listLength &lt; 3 || pos+listLength &gt; len(data) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Parse ServerName entries
                        <span class="cov8" title="1">listEnd := pos + listLength
                        for pos &lt; listEnd-3 </span><span class="cov8" title="1">{
                                // ServerName entry
                                nameType := data[pos]
                                nameLength := int(data[pos+1])&lt;&lt;8 | int(data[pos+2])
                                pos += 3

                                if pos+nameLength &gt; len(data) </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                // Check for host_name type (0x00)
                                <span class="cov8" title="1">if nameType == 0x00 </span><span class="cov8" title="1">{
                                        return string(data[pos : pos+nameLength])
                                }</span>

                                <span class="cov0" title="0">pos += nameLength</span>
                        }
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov8" title="1">pos += extLength</span>
        }

        <span class="cov8" title="1">return ""</span>
}

func Pipe(ctx context.Context, src, dst net.Conn, wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()
        defer dst.Close()

        buf := make([]byte, 4096) // BUFFER_SIZE is now in config package
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov0" title="0">
                        n, err := src.Read(buf)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                                _, err = dst.Write(buf[:n])
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

func ConnectDirect(host string, port int) (net.Conn, error) <span class="cov8" title="1">{
        return net.Dial("tcp", fmt.Sprintf("%s:%d", host, port))
}</span>

func ConnectViaProxy(proxyHost string, proxyPort int, targetHost string, targetPort int, clientIP string) (net.Conn, error) <span class="cov8" title="1">{
        conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", proxyHost, proxyPort))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">connectRequest := fmt.Sprintf(
                "CONNECT %s:%d HTTP/1.1\r\n"+
                        "Host: %s:%d\r\n"+
                        "X-Forwarded-For: %s\r\n"+
                        "Forwarded: for=%s\r\n"+
                        "\r\n",
                targetHost, targetPort,
                targetHost, targetPort,
                clientIP, clientIP,
        )

        if _, err := conn.Write([]byte(connectRequest)); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, err
        }</span>

        // Read proxy response
        <span class="cov8" title="1">reader := bufio.NewReader(conn)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(response, "HTTP/1.1 200") </span><span class="cov8" title="1">{
                conn.Close()
                return nil, fmt.Errorf("proxy connection failed: %s", response)
        }</span>

        // Read remaining headers until empty line
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                line, err := reader.ReadString('\n')
                if err != nil || line == "\r\n" </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return conn, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package server

import (
        "context"
        "fmt"
        "net"
        "sync"
        "syscall"
        "unsafe"

        "tproxy/internal/config"
        "tproxy/internal/proxy"
)

// Constants for SO_ORIGINAL_DST (Linux-specific)
const SO_ORIGINAL_DST = 80 // Typically 80 on Linux systems

// getOriginalDst gets the original destination using SO_ORIGINAL_DST (Linux only)
func getOriginalDst(conn net.Conn) (string, int, error) <span class="cov0" title="0">{
        // Get the underlying file descriptor
        tcpConn, ok := conn.(*net.TCPConn)
        if !ok </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("not a TCP connection")
        }</span>

        <span class="cov0" title="0">file, err := tcpConn.File()
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        fd := int(file.Fd())

        // Use getsockopt to get SO_ORIGINAL_DST
        var addr [16]byte
        addrLen := uint32(16)

        _, _, errno := syscall.Syscall6(
                syscall.SYS_GETSOCKOPT,
                uintptr(fd),
                syscall.IPPROTO_IP,
                SO_ORIGINAL_DST,
                uintptr(unsafe.Pointer(&amp;addr[0])),
                uintptr(unsafe.Pointer(&amp;addrLen)),
                0,
        )

        if errno != 0 </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("getsockopt failed: %v", errno)
        }</span>

        // Parse the result (similar to Python version)
        // Format: 2 bytes padding, 2 bytes port, 4 bytes IP, 8 bytes padding
        <span class="cov0" title="0">port := int(addr[2])&lt;&lt;8 | int(addr[3])
        ip := fmt.Sprintf("%d.%d.%d.%d", addr[4], addr[5], addr[6], addr[7])

        return ip, port, nil</span>
}

func handleHTTPSClient(conn net.Conn, rules []config.Rule) <span class="cov0" title="0">{
        defer conn.Close()

        clientIP := conn.RemoteAddr().String()
        originalIP := ""
        originalPort := config.DEFAULT_HTTPS_PORT

        // Try to get original destination using SO_ORIGINAL_DST
        ip, port, err := getOriginalDst(conn)
        if err == nil </span><span class="cov0" title="0">{
                originalIP = ip
                originalPort = port
        }</span> else<span class="cov0" title="0"> {
                // Fallback to RemoteAddr if SO_ORIGINAL_DST fails
                if tcpAddr, ok := conn.RemoteAddr().(*net.TCPAddr); ok </span><span class="cov0" title="0">{
                        originalIP = tcpAddr.IP.String()
                }</span>
        }

        // Read initial data to parse SNI
        <span class="cov0" title="0">buf := make([]byte, config.BUFFER_SIZE)
        n, err := conn.Read(buf)
        if err != nil || n == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">initialData := buf[:n]
        sni := proxy.ParseSNI(initialData)

        if sni == "" </span><span class="cov0" title="0">{
                fmt.Printf("SNI not found from %s -&gt; %s:%d\n", clientIP, originalIP, originalPort)
                // Use original IP as fallback (similar to Python version)
                if originalIP != "" </span><span class="cov0" title="0">{
                        sni = originalIP
                }</span> else<span class="cov0" title="0"> {
                        return
                }</span>
        }

        <span class="cov0" title="0">proxyAction, err := config.FindProxyForHost(sni, rules)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error finding proxy for %s: %v\n", sni, err)
                return
        }</span>

        <span class="cov0" title="0">proxyConnection(sni, originalPort, originalIP, clientIP, conn, proxyAction, initialData, true)</span>
}

func handleHTTPClient(conn net.Conn, rules []config.Rule) <span class="cov0" title="0">{
        defer conn.Close()

        clientIP := conn.RemoteAddr().String()
        originalIP := ""

        // Try to get original destination using SO_ORIGINAL_DST
        ip, _, err := getOriginalDst(conn)
        if err == nil </span><span class="cov0" title="0">{
                originalIP = ip
        }</span> else<span class="cov0" title="0"> {
                // Fallback to RemoteAddr if SO_ORIGINAL_DST fails
                if tcpAddr, ok := conn.RemoteAddr().(*net.TCPAddr); ok </span><span class="cov0" title="0">{
                        originalIP = tcpAddr.IP.String()
                }</span>
        }

        // Read initial data to parse Host header
        <span class="cov0" title="0">buf := make([]byte, config.BUFFER_SIZE)
        n, err := conn.Read(buf)
        if err != nil || n == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">initialData := buf[:n]
        host, port := proxy.ParseHTTPHost(initialData)

        if host == "" </span><span class="cov0" title="0">{
                fmt.Printf("Host header not found from %s\n", clientIP)
                return
        }</span>

        <span class="cov0" title="0">proxyAction, err := config.FindProxyForHost(host, rules)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error finding proxy for %s: %v\n", host, err)
                return
        }</span>

        <span class="cov0" title="0">proxyConnection(host, port, originalIP, clientIP, conn, proxyAction, initialData, false)</span>
}

func proxyConnection(
        targetHost string,
        targetPort int,
        originalIP string,
        clientIP string,
        clientConn net.Conn,
        proxyAction *config.ProxyAction,
        initialData []byte,
        isHTTPS bool,
) <span class="cov8" title="1">{
        // If originalIP is not provided, try to extract it from client connection
        if originalIP == "" </span><span class="cov0" title="0">{
                if tcpAddr, ok := clientConn.RemoteAddr().(*net.TCPAddr); ok </span><span class="cov0" title="0">{
                        originalIP = tcpAddr.IP.String()
                }</span>
        }

        <span class="cov8" title="1">if proxyAction.Type == "DROP" </span><span class="cov8" title="1">{
                fmt.Printf("%s =&gt; %s:%d: Drop for %s:%d\n", clientIP, originalIP, targetPort, targetHost, targetPort)
                return
        }</span>

        <span class="cov8" title="1">var remoteConn net.Conn
        var err error

        if proxyAction.Type == "PROXY" &amp;&amp; proxyAction.Host != "" &amp;&amp; proxyAction.Port != 0 </span><span class="cov8" title="1">{
                fmt.Printf("%s =&gt; %s:%d: Proxying connection for %s:%d via %s:%d\n",
                        clientIP, originalIP, targetPort, targetHost, targetPort, proxyAction.Host, proxyAction.Port)

                remoteConn, err = proxy.ConnectViaProxy(proxyAction.Host, proxyAction.Port, targetHost, targetPort, clientIP)
        }</span> else<span class="cov8" title="1"> {
                fmt.Printf("%s =&gt; %s:%d: Direct connection for %s:%d\n", clientIP, originalIP, targetPort, targetHost, targetPort)
                remoteConn, err = proxy.ConnectDirect(targetHost, targetPort)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Connection failed: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">defer remoteConn.Close()

        // Send initial data if we have it
        if len(initialData) &gt; 0 </span><span class="cov8" title="1">{
                if _, err := remoteConn.Write(initialData); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to send initial data: %v\n", err)
                        return
                }</span>
        }

        // Create context for cancellation
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        var wg sync.WaitGroup
        wg.Add(2)

        // Pipe data between client and remote
        go proxy.Pipe(ctx, clientConn, remoteConn, &amp;wg)
        go proxy.Pipe(ctx, remoteConn, clientConn, &amp;wg)

        wg.Wait()</span>
}

func StartServers(config *config.Config) error <span class="cov8" title="1">{
        listenConfig := config.Listen
        rules := config.Rules

        // Start HTTPS server
        httpsListener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", listenConfig.Host, listenConfig.HTTPSPort))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to start HTTPS server: %w", err)
        }</span>
        <span class="cov0" title="0">defer httpsListener.Close()

        // Start HTTP server
        httpListener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", listenConfig.Host, listenConfig.HTTPPort))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start HTTP server: %w", err)
        }</span>
        <span class="cov0" title="0">defer httpListener.Close()

        fmt.Printf("SNI proxy (HTTPS) listening on %s:%d\n", listenConfig.Host, listenConfig.HTTPSPort)
        fmt.Printf("Host proxy (HTTP) listening on %s:%d\n", listenConfig.Host, listenConfig.HTTPPort)
        fmt.Println("Routing rules:")
        for i, rule := range rules </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s -&gt; %s\n", i+1, rule.Pattern, rule.Proxy)
        }</span>

        // Handle HTTPS connections
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        conn, err := httpsListener.Accept()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("HTTPS accept error: %v\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">go handleHTTPSClient(conn, rules)</span>
                }
        }()

        // Handle HTTP connections
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                conn, err := httpListener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("HTTP accept error: %v\n", err)
                        continue</span>
                }
                <span class="cov0" title="0">go handleHTTPClient(conn, rules)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
